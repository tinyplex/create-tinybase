{{includeFile template="src/components/canvas.css.hbs" output="src/components/canvas.css"}}
import './canvas.css';

export const createCanvas = (store: any): HTMLCanvasElement => {
const canvas = document.createElement('canvas');
canvas.id = 'drawingCanvas';
canvas.width = 600;
canvas.height = 400;

const ctx = canvas.getContext('2d')!;
let isDrawing = false;

const draw = () => {
ctx.fillStyle = '#111';
ctx.fillRect(0, 0, canvas!.width, canvas!.height);

const strokes = store.getTable('strokes');
Object.values(strokes).forEach((stroke: any) => {
ctx.fillStyle = stroke.color;
ctx.beginPath();
ctx.arc(stroke.x, stroke.y, stroke.size, 0, Math.PI * 2);
ctx.fill();
});
};

const addStroke = (e: MouseEvent | TouchEvent) => {
const rect = canvas!.getBoundingClientRect();
const clientX = 'touches' in e ? e.touches[0].clientX : e.clientX;
const clientY = 'touches' in e ? e.touches[0].clientY : e.clientY;
const brush = store.getRow('settings', 'brush') as any;

store.addRow('strokes', {
x: clientX - rect.left,
y: clientY - rect.top,
color: brush.color,
size: brush.size,
});
};

canvas!.addEventListener('mousedown', () => { isDrawing = true; });
canvas!.addEventListener('mouseup', () => { isDrawing = false; });
canvas!.addEventListener('mouseleave', () => { isDrawing = false; });

canvas!.addEventListener('mousemove', (e) => {
if (isDrawing) addStroke(e);
});

canvas!.addEventListener('touchstart', (e) => {
isDrawing = true;
e.preventDefault();
});

canvas!.addEventListener('touchmove', (e) => {
if (isDrawing) {
addStroke(e);
e.preventDefault();
}
});

canvas!.addEventListener('touchend', () => {
isDrawing = false;
});

store.addTablesListener(draw);
draw();

return canvas;
};