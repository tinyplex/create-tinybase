{{includeFile template="client/src/drawing/canvas.css.hbs" output="client/src/canvas.css"}}
{{addImport "import {useCallback, useEffect, useRef} from 'react';"}}
{{addImport "import {useTable, useStore, STORE_ID as CANVAS_STORE_ID} from './CanvasStore';"}}
{{addImport "import {useValues, STORE_ID as SETTINGS_STORE_ID} from './SettingsStore';"}}
{{addImport "import {getUniqueId} from 'tinybase';"}}
{{addImport "import './canvas.css';"}}

export const Canvas = () => {
const canvasRef = useRef<HTMLCanvasElement>(null);
  const isDrawing = useRef(false);
  const currentStrokeId = useRef<string | null>(null);
    const brush = useValues(SETTINGS_STORE_ID);
    const strokes = useTable('strokes', CANVAS_STORE_ID);
    const store = useStore(CANVAS_STORE_ID);

    const draw = useCallback(() => {
    const canvas = canvasRef.current;
    if (!canvas) return;

    const ctx = canvas.getContext('2d');
    if (!ctx) return;

    ctx.fillStyle = '#111';
    ctx.fillRect(0, 0, canvas.width, canvas.height);

    Object.entries(strokes).forEach(([_id, stroke]) => {
    if (stroke && stroke.points) {
    const coords = JSON.parse(stroke.points as string) as number[];
    if (coords.length >= 2) {
    ctx.strokeStyle = stroke.color as string;
    ctx.lineWidth = (stroke.size as number) * 2;
    ctx.lineCap = 'round';
    ctx.lineJoin = 'round';
    ctx.beginPath();
    ctx.moveTo(coords[0], coords[1]);
    for (let i = 2; i < coords.length; i +=2) { ctx.lineTo(coords[i], coords[i + 1]); } ctx.stroke(); } } }); }, [strokes]); useEffect(()=> {
      draw();
      }, [draw]);

      const getPoint = (e: MouseEvent | TouchEvent) => {
      const canvas = canvasRef.current;
      if (!canvas) return null;

      const rect = canvas.getBoundingClientRect();
      const clientX = 'touches' in e ? e.touches[0].clientX : e.clientX;
      const clientY = 'touches' in e ? e.touches[0].clientY : e.clientY;

      return {
      x: clientX - rect.left,
      y: clientY - rect.top,
      };
      };

      const handleStart = (e: React.MouseEvent | React.TouchEvent) => {
      isDrawing.current = true;
      currentStrokeId.current = getUniqueId();

      const point = getPoint(e.nativeEvent);
      if (point && store) {
      store.setRow('strokes', currentStrokeId.current, {
      color: brush.brushColor,
      size: brush.brushSize,
      points: JSON.stringify([point.x, point.y]),
      });
      }
      };

      const handleMove = (e: React.MouseEvent | React.TouchEvent) => {
      if (isDrawing.current && currentStrokeId.current && store) {
      const point = getPoint(e.nativeEvent);
      if (point) {
      const stroke = store.getRow('strokes', currentStrokeId.current);
      const coords = stroke?.points ? JSON.parse(stroke.points as string) : [];
      coords.push(point.x, point.y);
      store.setCell('strokes', currentStrokeId.current, 'points', JSON.stringify(coords));
      }
      }
      };

      const handleEnd = () => {
      isDrawing.current = false;
      currentStrokeId.current = null;
      };

      return (
      <canvas ref={canvasRef} width={600} height={400} id="drawingCanvas" onMouseDown={handleStart} onMouseMove={handleMove} onMouseUp={handleEnd} onMouseLeave={handleEnd} onTouchStart={handleStart} onTouchMove={handleMove}
        onTouchEnd={handleEnd} />
      );
      };