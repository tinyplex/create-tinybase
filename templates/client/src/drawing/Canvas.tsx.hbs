{{includeFile template="client/src/drawing/canvas.css.hbs" output="client/src/canvas.css"}}
{{addImport "import {useCallback, useEffect, useRef} from 'react';"}}
{{addImport "import {useSortedRowIds, useTable, useStore, type StrokeRow, STORE_ID as CANVAS_STORE_ID} from './CanvasStore';"}}
{{addImport "import {useValues, STORE_ID as SETTINGS_STORE_ID} from './SettingsStore';"}}
{{addImport "import {getHlcFunctions} from 'tinybase';"}}
{{addImport "import './canvas.css';"}}

const [getNextHlc] = getHlcFunctions();

export const Canvas = () => {
const canvasRef = useRef<HTMLCanvasElement>(null);
  const isDrawing = useRef(false);
  const currentStrokeId = useRef<string | null>(null);
    const {brushColor, brushSize} = useValues(SETTINGS_STORE_ID);
    const sortedIds = useSortedRowIds('strokes', undefined, false, 0, undefined, CANVAS_STORE_ID);
    const strokes = useTable('strokes', CANVAS_STORE_ID);
    const store = useStore(CANVAS_STORE_ID);

    const draw = useCallback(() => {
    const canvas = canvasRef.current;
    if (!canvas) return;

    const ctx = canvas.getContext('2d');
    if (!ctx) return;

    ctx.fillStyle = '#111';
    ctx.fillRect(0, 0, canvas.width, canvas.height);

    sortedIds.forEach((id) => {
    const stroke = store?.getRow('strokes', id) as StrokeRow;
    if (stroke?.points) {
    const pointsArray = JSON.parse(stroke.points) as number[];
    if (pointsArray.length >= 2) {
    ctx.strokeStyle = stroke.color;
    ctx.lineWidth = stroke.size * 2;
    ctx.lineCap = 'round';
    ctx.lineJoin = 'round';
    ctx.beginPath();
    ctx.moveTo(pointsArray[0], pointsArray[1]);
    for (let i = 2; i < pointsArray.length; i +=2) { ctx.lineTo(pointsArray[i], pointsArray[i + 1]); } ctx.stroke(); } } }); }, [sortedIds, strokes, store]); useEffect(()=> {
      draw();
      }, [draw]);

      const getPoint = (e: MouseEvent | TouchEvent) => {
      const canvas = canvasRef.current;
      if (!canvas) return null;

      const rect = canvas.getBoundingClientRect();
      const clientX = 'touches' in e ? e.touches[0].clientX : e.clientX;
      const clientY = 'touches' in e ? e.touches[0].clientY : e.clientY;

      return {
      x: clientX - rect.left,
      y: clientY - rect.top,
      };
      };

      const handleStart = (e: React.MouseEvent | React.TouchEvent) => {
      isDrawing.current = true;
      currentStrokeId.current = getNextHlc();

      const point = getPoint(e.nativeEvent);
      if (point && store) {
      store.setRow('strokes', currentStrokeId.current, {
      color: brushColor,
      size: brushSize,
      points: JSON.stringify([point.x, point.y]),
      });
      }
      };

      const handleMove = (e: React.MouseEvent | React.TouchEvent) => {
      if (isDrawing.current && currentStrokeId.current && store) {
      const point = getPoint(e.nativeEvent);
      if (point) {
      const pointsArray = JSON.parse(store.getCell('strokes', currentStrokeId.current, 'points') as string ?? '[]');
      pointsArray.push(point.x, point.y);
      store.setCell('strokes', currentStrokeId.current, 'points', JSON.stringify(pointsArray));
      }
      }
      };

      const handleEnd = () => {
      isDrawing.current = false;
      currentStrokeId.current = null;
      };

      return (
      <canvas ref={canvasRef} width={600} height={400} id="drawingCanvas" onMouseDown={handleStart} onMouseMove={handleMove} onMouseUp={handleEnd} onMouseLeave={handleEnd} onTouchStart={handleStart} onTouchMove={handleMove}
        onTouchEnd={handleEnd} />
      );
      };