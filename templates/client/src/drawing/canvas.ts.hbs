{{includeFile template="client/src/drawing/canvas.css.hbs" output="client/src/canvas.css"}}
{{addImport "import './canvas.css';"}}
{{addImport "import {getUniqueId} from 'tinybase';"}}
{{addImport "import type {SettingsStore} from './settingsStore';"}}
{{addImport "import type {CanvasStore, StrokeRow} from './canvasStore';"}}

export const createCanvas = (settingsStore: SettingsStore, canvasStore: CanvasStore): HTMLCanvasElement => {
const canvas = document.createElement('canvas');
canvas.id = 'drawingCanvas';
canvas.width = 600;
canvas.height = 400;

const ctx = canvas.getContext('2d')!;
let isDrawing = false;
let currentStrokeId: string | null = null;

const draw = () => {
ctx.fillStyle = '#111';
ctx.fillRect(0, 0, canvas!.width, canvas!.height);

const sortedIds = canvasStore.getSortedRowIds('strokes');
sortedIds.forEach((id) => {
const stroke = canvasStore.getRow('strokes', id) as StrokeRow;
if (stroke.points) {
const pointsArray = JSON.parse(stroke.points) as number[];
if (pointsArray.length >= 2) {
ctx.strokeStyle = stroke.color;
ctx.lineWidth = stroke.size * 2;
ctx.lineCap = 'round';
ctx.lineJoin = 'round';
ctx.beginPath();
ctx.moveTo(pointsArray[0], pointsArray[1]);
for (let i = 2; i < pointsArray.length; i +=2) { ctx.lineTo(pointsArray[i], pointsArray[i + 1]); } ctx.stroke(); } } }); }; const addPoint=(e: MouseEvent | TouchEvent)=> {
  if (!currentStrokeId) return;

  const rect = canvas!.getBoundingClientRect();
  const clientX = 'touches' in e ? e.touches[0].clientX : e.clientX;
  const clientY = 'touches' in e ? e.touches[0].clientY : e.clientY;

  const pointsArray = JSON.parse(canvasStore.getCell('strokes', currentStrokeId, 'points') as string ?? '[]') as number[];
  pointsArray.push(clientX - rect.left, clientY - rect.top);
  canvasStore.setCell('strokes', currentStrokeId, 'points', JSON.stringify(pointsArray));
  };

  const startStroke = (e: MouseEvent | TouchEvent) => {
  const {brushColor, brushSize} = settingsStore.getValues();
  currentStrokeId = getUniqueId();

  canvasStore.setRow('strokes', currentStrokeId, {
  color: brushColor,
  size: brushSize,
  points: '[]',
  });

  addPoint(e);
  };

  canvas.addEventListener('mousedown', (e) => {
  isDrawing = true;
  startStroke(e);
  });

  canvas.addEventListener('mouseup', () => {
  isDrawing = false;
  currentStrokeId = null;
  });

  canvas.addEventListener('mouseleave', () => {
  isDrawing = false;
  currentStrokeId = null;
  });

  canvas.addEventListener('mousemove', (e) => {
  if (isDrawing) addPoint(e);
  });

  canvas.addEventListener('touchstart', (e) => {
  isDrawing = true;
  startStroke(e);
  e.preventDefault();
  });

  canvas.addEventListener('touchmove', (e) => {
  if (isDrawing) {
  addPoint(e);
  e.preventDefault();
  }
  });

  canvas.addEventListener('touchend', () => {
  isDrawing = false;
  currentStrokeId = null;
  });

  canvasStore.addTablesListener(draw);
  draw();

  return canvas;
  };