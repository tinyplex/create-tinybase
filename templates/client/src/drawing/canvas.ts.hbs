{{includeFile template="client/src/drawing/canvas.css.hbs" output="client/src/canvas.css"}}
{{addImport "import './canvas.css';"}}
{{addImport "import {getUniqueId} from 'tinybase';"}}
{{addImport "import type {SettingsStore} from './settingsStore';"}}
{{addImport "import type {CanvasStore} from './canvasStore';"}}

export const createCanvas = (settingsStore: SettingsStore, canvasStore: CanvasStore): HTMLCanvasElement => {
const canvas = document.createElement('canvas');
canvas.id = 'drawingCanvas';
canvas.width = 600;
canvas.height = 400;

const ctx = canvas.getContext('2d')!;
let isDrawing = false;
let currentStrokeId: string | null = null;

const draw = () => {
ctx.fillStyle = '#111';
ctx.fillRect(0, 0, canvas!.width, canvas!.height);

const strokes = canvasStore.getTable('strokes');
Object.entries(strokes).forEach(([_id, stroke]: [string, any]) => {
if (stroke.points) {
const coords = JSON.parse(stroke.points) as number[];
if (coords.length >= 2) {
ctx.strokeStyle = stroke.color;
ctx.lineWidth = stroke.size * 2;
ctx.lineCap = 'round';
ctx.lineJoin = 'round';
ctx.beginPath();
ctx.moveTo(coords[0], coords[1]);
for (let i = 2; i < coords.length; i +=2) { ctx.lineTo(coords[i], coords[i + 1]); } ctx.stroke(); } } }); }; const addPoint=(e: MouseEvent | TouchEvent)=> {
  if (!currentStrokeId) return;

  const rect = canvas!.getBoundingClientRect();
  const clientX = 'touches' in e ? e.touches[0].clientX : e.clientX;
  const clientY = 'touches' in e ? e.touches[0].clientY : e.clientY;

  const stroke = canvasStore.getRow('strokes', currentStrokeId);
  const coords = stroke?.points ? JSON.parse(stroke.points as string) : [];
  coords.push(clientX - rect.left, clientY - rect.top);
  canvasStore.setCell('strokes', currentStrokeId, 'points', JSON.stringify(coords));
  };

  const startStroke = (e: MouseEvent | TouchEvent) => {
  const brush = settingsStore.getValues() as any;
  currentStrokeId = getUniqueId();

  canvasStore.setRow('strokes', currentStrokeId, {
  color: brush.brushColor,
  size: brush.brushSize,
  points: '[]',
  });

  addPoint(e);
  };

  canvas.addEventListener('mousedown', (e) => {
  isDrawing = true;
  startStroke(e);
  });

  canvas.addEventListener('mouseup', () => {
  isDrawing = false;
  currentStrokeId = null;
  });

  canvas.addEventListener('mouseleave', () => {
  isDrawing = false;
  currentStrokeId = null;
  });

  canvas.addEventListener('mousemove', (e) => {
  if (isDrawing) addPoint(e);
  });

  canvas.addEventListener('touchstart', (e) => {
  isDrawing = true;
  startStroke(e);
  e.preventDefault();
  });

  canvas.addEventListener('touchmove', (e) => {
  if (isDrawing) {
  addPoint(e);
  e.preventDefault();
  }
  });

  canvas.addEventListener('touchend', () => {
  isDrawing = false;
  currentStrokeId = null;
  });

  canvasStore.addTablesListener(draw);
  draw();

  return canvas;
  };